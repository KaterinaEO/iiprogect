from aiogram import Bot, Dispatcher, types
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton
from aiogram.utils import executor
from aiogram.dispatcher import FSMContext
from aiogram.dispatcher.filters.state import State, StatesGroup
from aiogram.contrib.fsm_storage.memory import MemoryStorage
import pandas as pd
from gigachat import GigaChat
import logging

logging.basicConfig(level=logging.INFO)

TOKEN = "7942315281:AAHz_poSfJwBAcmucOpOCY4YXPToMIH1XvQ"

bot = Bot(token=TOKEN)
storage = MemoryStorage()
dp = Dispatcher(bot, storage=storage)

df = pd.read_csv("mal_manga_df.csv")


class MangaSearch(StatesGroup):
    title = State()
    genres = State()
    filters = State()
    analysis = State()
    comparison = State()
    podborka = State()
    filter_choice = State()
    filter_input = State()
    filter_page = State()
    past = State()


def find_manga_by_title(title):
    return df[df['title'].str.contains(title, case=False, na=False)].head(5).to_dict(orient='records')


def find_manga_by_genres(genres):
    filtered_df = df[df['genres'].fillna('').apply(lambda x: any(g in x.lower() for g in genres))]
    return filtered_df.head(5).to_dict(orient='records')


def count_matches(manga, year, author, genres, rating):
    matches = 0
    if year and manga['year'] == int(year):
        matches += 1
    if author and author.lower() in manga['author'].lower():
        matches += 1
    if genres:
        if any(g.lower() in manga['genres'].lower() for g in genres):
            matches += 1
    if rating and manga['score'] >= float(rating):
        matches += 1
    return matches


def find_manga_by_filters(year=None, author=None, genres=None, rating=None):
    filtered_df = df.copy()
    filtered_df['match_count'] = filtered_df.apply(lambda row: count_matches(row, year, author, genres, rating), axis=1)
    filtered_df = filtered_df[filtered_df['match_count'] > 0]
    filtered_df = filtered_df.sort_values(by='match_count', ascending=False)
    return filtered_df


async def get_mangas_page(filters, page=0):
    year = filters.get('year')
    author = filters.get('author')
    genres = filters.get('genres')
    rating = filters.get('rating')

    mangas = find_manga_by_filters(year, author, genres, rating)
    mangas_sorted = mangas.sort_values(by='match_count', ascending=False)

    start_idx = page * 5
    end_idx = start_idx + 5

    return mangas_sorted.iloc[start_idx:end_idx]


gigaChatKey = "M2U0OWIxNDUtNDZhNS00MjM2LTllYzYtOThkMjc5NzQ5ZTJlOjZlMzQxZWRmLTNlODMtNDVhZi05NDY5LTAxNGI3NjcxZWQ1MA=="
llm = GigaChat(credentials=gigaChatKey, model='GigaChat:latest', verify_ssl_certs=False)

main_menu = ReplyKeyboardMarkup(resize_keyboard=True)
main_menu.add(KeyboardButton("–ú–∞–Ω–≥–∞ –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é"))
main_menu.add(KeyboardButton("–ú–∞–Ω–≥–∏ –ø–æ –∂–∞–Ω—Ä–∞–º"))
main_menu.add(KeyboardButton("–§–∏–ª—å—Ç—Ä—ã"))
main_menu.add(KeyboardButton("–ê–Ω–∞–ª–∏–∑ –º–∞–Ω–≥–∏"))
main_menu.add(KeyboardButton("–ü—Ä–µ–¥—ã–¥—É—â–∏–µ –ø–æ–¥–±–æ—Ä–∫–∏"))
main_menu.add(KeyboardButton("–°—Ä–∞–≤–Ω–µ–Ω–∏–µ –º–∞–Ω–≥"))
main_menu.add(KeyboardButton("–ü–æ–¥–±–æ—Ä–∫–∞ –ø–æ –æ–ø–∏—Å–∞–Ω–∏—é"))

filter_menu = ReplyKeyboardMarkup(resize_keyboard=True)
filter_menu.add(KeyboardButton("–ù–æ–≤—ã–µ —Ñ–∏–ª—å—Ç—Ä—ã"))
filter_menu.add(KeyboardButton("–°—Ç–∞—Ä—ã–µ —Ñ–∏–ª—å—Ç—Ä—ã"))
filter_menu.add(KeyboardButton("–ù–∞–∑–∞–¥"))

pagination_menu = ReplyKeyboardMarkup(resize_keyboard=True)
pagination_menu.add(KeyboardButton("–°–ª–µ–¥—É—é—â–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞"))
pagination_menu.add(KeyboardButton("–ù–∞–∑–∞–¥"))

user_recommendations = {}
user_filters = {}
user_pages = {}


@dp.message_handler(commands=['start'])
async def start(message: types.Message):
    await message.answer("–ü—Ä–∏–≤–µ—Ç! –Ø –±–æ—Ç –¥–ª—è –ø–æ–∏—Å–∫–∞ –º–∞–Ω–≥–∏. –í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:", reply_markup=main_menu)


@dp.message_handler(lambda message: message.text == "–ú–∞–Ω–≥–∞ –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é")
async def manga_by_title(message: types.Message):
    await message.answer("–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –º–∞–Ω–≥–∏ –¥–ª—è –ø–æ–∏—Å–∫–∞:")
    await MangaSearch.title.set()


@dp.message_handler(state=MangaSearch.title)
async def search_manga_by_title(message: types.Message, state: FSMContext):
    title = message.text.strip()
    mangas = find_manga_by_title(title)

    if mangas:
        response = "\n\n".join(
            [f"üìñ *{m['title']}*\n‚≠ê –†–µ–π—Ç–∏–Ω–≥: {m.get('score', '–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö')}\nüìï –ñ–∞–Ω—Ä—ã: {m.get('genres', '–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö')}"
             for m in mangas])
    else:
        response = "‚ùå –ú–∞–Ω–≥–∞ —Å —Ç–∞–∫–∏–º –Ω–∞–∑–≤–∞–Ω–∏–µ–º –Ω–µ –Ω–∞–π–¥–µ–Ω–∞."

    user_id = message.from_user.id
    user_recommendations.setdefault(user_id, []).append(response)
    logging.info(f"–ü–æ–¥–±–æ—Ä–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}: {response}")
    await message.answer(response, parse_mode="Markdown", reply_markup=main_menu)
    await state.finish()


@dp.message_handler(lambda message: message.text == "–ú–∞–Ω–≥–∏ –ø–æ –∂–∞–Ω—Ä–∞–º")
async def manga_by_genres(message: types.Message):
    await message.answer("–í–≤–µ–¥–∏—Ç–µ –∂–∞–Ω—Ä—ã –º–∞–Ω–≥–∏ —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é:")
    await MangaSearch.genres.set()


@dp.message_handler(state=MangaSearch.genres)
async def search_manga_by_genres(message: types.Message, state: FSMContext):
    genres = message.text.split(',')
    genres = [g.strip().lower() for g in genres]
    mangas = find_manga_by_genres(genres)

    if mangas:
        response = "\n\n".join(
            [f"üìñ *{m['title']}*\n‚≠ê –†–µ–π—Ç–∏–Ω–≥: {m.get('score', '–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö')}\nüìï –ñ–∞–Ω—Ä—ã: {m.get('genres', '–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö')}"
             for m in mangas])
    else:
        response = "‚ùå –ú–∞–Ω–≥–∞ —Å —Ç–∞–∫–∏–º–∏ –∂–∞–Ω—Ä–∞–º–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞."

    user_id = message.from_user.id
    user_recommendations.setdefault(user_id, []).append(response)
    logging.info(f"–ü–æ–¥–±–æ—Ä–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}: {response}")  # –õ–æ–≥–∏—Ä—É–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ

    await message.answer(response, parse_mode="Markdown", reply_markup=main_menu)
    await state.finish()


@dp.message_handler(lambda message: message.text == "–§–∏–ª—å—Ç—Ä—ã")
async def filter_menu_handler(message: types.Message):
    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:", reply_markup=filter_menu)
    await MangaSearch.filter_choice.set()


@dp.message_handler(lambda message: message.text == "–ù–æ–≤—ã–µ —Ñ–∏–ª—å—Ç—Ä—ã", state=MangaSearch.filter_choice)
async def new_filters(message: types.Message):
    await message.answer(
        "–í–≤–µ–¥–∏—Ç–µ —Ñ–∏–ª—å—Ç—Ä—ã –≤ —Ñ–æ—Ä–º–∞—Ç–µ: –∫—Ä–∏—Ç–µ—Ä–∏–π: –∑–Ω–∞—á–µ–Ω–∏–µ (–Ω–∞–ø—Ä–∏–º–µ—Ä, '–≥–æ–¥: 2020, –∞–≤—Ç–æ—Ä: –•–∞—Ä—É–∫–∏'). –í—ã –º–æ–∂–µ—Ç–µ –æ—Å—Ç–∞–≤–∏—Ç—å –ª—é–±–æ–π –ø–∞—Ä–∞–º–µ—Ç—Ä –ø—É—Å—Ç—ã–º.")
    await MangaSearch.filter_input.set()


@dp.message_handler(state=MangaSearch.filter_input)
async def process_new_filters(message: types.Message, state: FSMContext):
    filters = message.text.split(',')
    filter_dict = {'year': None, 'author': None, 'genres': None, 'rating': None}

    for f in filters:
        f = f.strip().lower()
        if "–≥–æ–¥:" in f:
            filter_dict['year'] = f.replace("–≥–æ–¥:", "").strip()
        elif "–∞–≤—Ç–æ—Ä:" in f:
            filter_dict['author'] = f.replace("–∞–≤—Ç–æ—Ä:", "").strip()
        elif "–∂–∞–Ω—Ä—ã:" in f:
            filter_dict['genres'] = [g.strip() for g in f.replace("–∂–∞–Ω—Ä—ã:", "").strip().split(';')]
        elif "—Ä–µ–π—Ç–∏–Ω–≥:" in f:
            try:
                filter_dict['rating'] = float(f.replace("—Ä–µ–π—Ç–∏–Ω–≥:", "").strip())
            except ValueError:
                filter_dict['rating'] = None

    user_filters[message.from_user.id] = filter_dict
    user_pages[message.from_user.id] = 0
    await state.finish()
    await old_filters(message, state)


@dp.message_handler(lambda message: message.text == "–°—Ç–∞—Ä—ã–µ —Ñ–∏–ª—å—Ç—Ä—ã", state=MangaSearch.filter_choice)
async def old_filters(message: types.Message, state: FSMContext):
    filters = user_filters.get(message.from_user.id)
    if not filters:
        await message.answer("‚ùå –£ –≤–∞—Å –Ω–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã—Ö —Ñ–∏–ª—å—Ç—Ä–æ–≤.", reply_markup=main_menu)
        await state.finish()
        return

    user_pages[message.from_user.id] = 0
    mangas_page = await get_mangas_page(filters, page=user_pages[message.from_user.id])
    if mangas_page.empty:
        await message.answer("‚ùå –ú–∞–Ω–≥–∞ –ø–æ –¥–∞–Ω–Ω—ã–º —Ñ–∏–ª—å—Ç—Ä–∞–º –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.", reply_markup=main_menu)
    else:
        response = "\n\n".join([
            f"üìñ *{m['title']}*\n‚≠ê –†–µ–π—Ç–∏–Ω–≥: {m.get('score', '–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö')}\nüìï –ñ–∞–Ω—Ä—ã: {m.get('genres', '–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö')}"
            for _, m in mangas_page.iterrows()])
        user_id = message.from_user.id
        user_recommendations.setdefault(user_id, []).append(response)
        logging.info(f"–ü–æ–¥–±–æ—Ä–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}: {response}")  # –õ–æ–≥–∏—Ä—É–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ

        await message.answer(response, parse_mode="Markdown", reply_markup=main_menu)

    await state.finish()


@dp.message_handler(lambda message: message.text == "–ù–∞–∑–∞–¥", state=MangaSearch.filter_choice)
async def back_to_main_menu(message: types.Message):
    await message.answer("–í–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é.", reply_markup=main_menu)
    await MangaSearch.filter_choice.finish()


@dp.message_handler(lambda message: message.text == "–ê–Ω–∞–ª–∏–∑ –º–∞–Ω–≥–∏")
async def analyze_manga(message: types.Message):
    await message.answer("–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –º–∞–Ω–≥–∏ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞:")
    await MangaSearch.analysis.set()


@dp.message_handler(state=MangaSearch.analysis)
async def get_manga_analysis(message: types.Message, state: FSMContext):
    title = message.text.strip()
    manga = find_manga_by_title(title)

    if manga:
        analysis_text = llm.chat(f"–ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π –º–∞–Ω–≥—É {title}. –î–∞–π –∫—Ä–∞—Ç–∫–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ —Å—é–∂–µ—Ç–∞ –∏ –æ—Ü–µ–Ω–∫—É.")
        result_text = analysis_text.choices[0].message.content
        await message.answer(result_text)
        user_recommendations.setdefault(message.from_user.id, []).append(f"üìñ *{title}* - {result_text}")
    else:
        await message.answer("‚ùå –ú–∞–Ω–≥–∞ —Å —Ç–∞–∫–∏–º –Ω–∞–∑–≤–∞–Ω–∏–µ–º –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.")

    await state.finish()


@dp.message_handler(lambda message: message.text == "–°—Ä–∞–≤–Ω–µ–Ω–∏–µ –º–∞–Ω–≥")
async def compare_mangas(message: types.Message):
    await message.answer("–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏—è –º–∞–Ω–≥ –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è, —Ä–∞–∑–¥–µ–ª—ë–Ω–Ω—ã–µ –∑–∞–ø—è—Ç–æ–π:")
    await MangaSearch.comparison.set()


@dp.message_handler(state=MangaSearch.comparison)
async def get_manga_comparison(message: types.Message, state: FSMContext):
    titles = message.text.split(',')
    if titles:
        comparison_text = llm.chat(
            f"–°—Ä–∞–≤–Ω–∏ –æ—á–µ–Ω—å –∫–æ—Ä–æ—Ç–∫–æ –º–∞–Ω–≥–∏ {titles}. –ö–∞–∫–∏–µ –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏ –∏ —Ä–∞–∑–ª–∏—á–∏—è —É —ç—Ç–∏—Ö –º–∞–Ω–≥?")
        result_text = comparison_text.choices[0].message.content
        await message.answer(result_text)
        user_recommendations.setdefault(message.from_user.id, []).append(
            f"üìñ –°—Ä–∞–≤–Ω–µ–Ω–∏–µ: {result_text}")
    else:
        await message.answer("‚ùå –ú–∞–Ω–≥–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.")

    await state.finish()


@dp.message_handler(lambda message: message.text == "–ü–æ–¥–±–æ—Ä–∫–∞ –ø–æ –æ–ø–∏—Å–∞–Ω–∏—é")
async def description_based_podborka(message: types.Message):
    await message.answer("–í–≤–µ–¥–∏—Ç–µ –æ–ø–∏—Å–∞–Ω–∏–µ, –ø–æ –∫–æ—Ç–æ—Ä–æ–º—É –≤—ã —Ö–æ—Ç–∏—Ç–µ –ø–æ–ª—É—á–∏—Ç—å –ø–æ–¥–±–æ—Ä–∫—É –º–∞–Ω–≥–∏:")
    await MangaSearch.podborka.set()


@dp.message_handler(state=MangaSearch.podborka)
async def get_podborka_by_description(message: types.Message, state: FSMContext):
    description = message.text.strip()
    podborka_text = llm.chat(f"–ù–∞–π–¥–∏ –º–∞–Ω–≥—É –ø–æ –æ–ø–∏—Å–∞–Ω–∏—é: {description}")
    result_text = podborka_text.choices[0].message.content
    await message.answer(result_text)
    user_recommendations.setdefault(message.from_user.id, []).append(f"–ü–æ–¥–±–æ—Ä–∫–∞ –ø–æ –æ–ø–∏—Å–∞–Ω–∏—é: {result_text}")

    await state.finish()


@dp.message_handler(lambda message: message.text == "–ü—Ä–µ–¥—ã–¥—É—â–∏–µ –ø–æ–¥–±–æ—Ä–∫–∏")
async def past_recommendations(message: types.Message):
    user_id = message.from_user.id
    if user_id not in user_recommendations or not user_recommendations[user_id]:
        await message.answer("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö –ø–æ–¥–±–æ—Ä–æ–∫.", reply_markup=main_menu)
        return

    recommendations = user_recommendations[user_id]
    logging.info(f"–ü–æ–¥–±–æ—Ä–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}: {recommendations}")
    response = "üìö –í–∞—à–∏ –ø—Ä–µ–¥—ã–¥—É—â–∏–µ –ø–æ–¥–±–æ—Ä–∫–∏:\n\n" + "\n\n".join(recommendations)
    await message.answer(response, parse_mode="Markdown", reply_markup=main_menu)


@dp.message_handler()
async def handle_unknown(message: types.Message):
    user_input = message.text.strip()

    if user_input not in ["–ú–∞–Ω–≥–∞ –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é", "–ú–∞–Ω–≥–∏ –ø–æ –∂–∞–Ω—Ä–∞–º", "–§–∏–ª—å—Ç—Ä—ã", "–ê–Ω–∞–ª–∏–∑ –º–∞–Ω–≥–∏", "–°—Ä–∞–≤–Ω–µ–Ω–∏–µ –º–∞–Ω–≥", "–ü–æ–¥–±–æ—Ä–∫–∞ –ø–æ –æ–ø–∏—Å–∞–Ω–∏—é", "–ü—Ä–µ–¥—ã–¥—É—â–∏–µ –ø–æ–¥–±–æ—Ä–∫–∏"]:
        response = llm.chat(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–∞–ø–∏—Å–∞–ª: '{user_input}'.–ï—Å–ª–∏ –∑–∞–ø—Ä–æ—Å —Ä–∞—Å–ø–ª—ã–≤—á–∞—Ç—ã–π, —Ç–æ –∑–∞–¥–∞–π –≤–æ–ø—Ä–æ—Å, –µ—Å–ª–∏ –ø–æ–Ω—è—Ç–Ω—ã–π, —Ç–æ –≤—ã–¥–∞–≤–∞–π 5 –º–∞–Ω–≥–∞ –≤ –∫–∞—á–µ—Å—Ç–≤–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏")
        bot_response = response.choices[0].message.content

        await message.answer(bot_response, parse_mode="Markdown", reply_markup=main_menu)


if __name__ == "__main__":
    executor.start_polling(dp, skip_updates=True)
